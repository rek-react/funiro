{"version":3,"sources":["gallery.js"],"names":["Gallery","static","wheel","spaceBetween","visibleItems","galleryPopup","border","responsive","autoScroll","interval","nav","dotts","keyControl","mouse","animated","baseTransition","delayTimer","touch","limit","visibilityStart","constructor","gallery","setup","this","slider","querySelector","stage","items","querySelectorAll","count","length","current","next","pressed","start","shift","init","out","i","arguments","key","hasOwnProperty","e","targetTouches","clientX","options","extend","defaults","setSizeCarousel","setCoordinates","initControl","events","registerEventsHandler","widthSlider","offsetWidth","setAdaptiveOptions","max","width","widths","style","item","cssText","visibility","setTimeout","point","coordinates","push","navGallery","dottsGallery","btnPrev","btnNext","setNavStyle","dataset","hidden","creatDotsCtrl","document","documentElement","clientWidth","points","adaptive","j","a","b","undefined","setting","classList","remove","add","spots","innerHTML","li","createElement","span","clone","appendChild","cloneNode","setDotsStyle","spot","Math","trunc","window","addEventListener","resize","bind","setInterval","navControl","dotsControl","wheelControl","tap","drag","release","clearTimeout","resizeTimer","x","scroll","getNextCoordinates","target","tagName","d","contains","indexOf","n","abs","t","which","RIGHT","LEFT","preventDefault","deltaY","stopPropagation","xpos","remaining","delta","round","popups","index","popup","imageItems","btnClose","imageItem","galleryPopupOpen","galleryPopupClose","galleryPopupCloseBtn","PaddingLock","innerWidth","body","paddingRight","targetItem","currentTarget","indexItem","Array","from","closest","direction","transition","offsetHeight"],"mappings":"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","file":"gallery.min.js","sourcesContent":["class Gallery {\r\n   // настройки по-умолчанию\r\n   static defaults = {\r\n      wheel: false,\r\n      spaceBetween: 30,\t\t// расстояние между элементами [px]\r\n      visibleItems: 1,\t\t// сколько элементов показывать одновременно\r\n      galleryPopup: true,\r\n      border: 0,\t\t// толщина рамки изображения прописанная в CSS [px]\r\n      responsive: false,\t// адаптивная галерея\r\n      autoScroll: false,\t// автоматическое прокручивание\r\n      interval: 3000,\t// задержка при автоматическом прокручивании [ms]\r\n      nav: true,\t// показать/скрыть кнопки next/prev\r\n      dotts: false,\t// показать/скрыть постраничную навигацию\r\n      keyControl: false,\t// управление клавишами вправо / влево\r\n      mouse: false,\r\n      animated: false,\t// включение анимации\r\n      baseTransition: 0.4,\t// скорость анимации, при изменении CSS свойств\r\n      delayTimer: 250,\t// время задержки при resize страницы [ms]\r\n      touch: true,\r\n      limit: 30,\t\t// ограничиваем перемещение крайних элементов [px]\r\n      visibilityStart: false,\r\n   };\r\n   static LEFT = 37;\t// код клавиши 'стрелочка влево' \r\n   static RIGHT = 39;\t// код клавиши 'стрелочка вправо'\r\n\r\n   constructor(gallery, setup) {\r\n      this.gallery = gallery;\r\n      this.setup = setup;\r\n\r\n      // контейнер в котором отображаются элементы галереи\r\n      this.slider = this.gallery.querySelector('.slider');\r\n      // контейнер, непосредственно в котором расположены элементы слайдера\r\n      this.stage = this.gallery.querySelector('.stage');\r\n      // элементы слайдера\r\n      this.items = this.gallery.querySelectorAll('.item');\r\n      // количество элементов в слайдере\r\n      this.count = this.items.length;\r\n\r\n\r\n\r\n      this.current = 0;\t\t// index координаты текущего элемента\r\n      this.next = 0;\t\t\t// index координаты следующего элемента\r\n      this.pressed = false;\t// указывает, что совершилось событие 'mousedown'\r\n      this.start = 0;\t\t\t// координата, с которой начато перетаскивание\r\n      this.shift = 0;\t\t\t// на сколько был перемещён курсор относительно start\r\n\r\n      // построение галереи исходя из полученных настроек\r\n      this.init();\r\n   }\r\n\r\n   // объединяет и перезаписывает значения двух объектов\r\n   // и выдаёт общий результат\r\n   static extend(out) {\r\n      out = out || {};\r\n      for (let i = 1; i < arguments.length; i++) {\r\n         if (!arguments[i]) continue;\r\n         for (let key in arguments[i]) {\r\n            if (arguments[i].hasOwnProperty(key)) out[key] = arguments[i][key];;\r\n         }\r\n      }\r\n      return out;\r\n   };\r\n\r\n   // возвращает координату Х текущего положения\r\n   // курсора или пальца\r\n   static xpos(e) {\r\n      // touch event\r\n      // проверяем, сформирован ли список точек на текущем элементе\r\n      // (список пальцев, которые вступили в контакт)\r\n      if (e.targetTouches && (e.targetTouches.length >= 1)) {\r\n         // положение первой точки прикосновения, относительно левого края браузера\r\n         return e.targetTouches[0].clientX;\r\n      }\r\n      // mouse event\r\n      return e.clientX;\r\n   }\r\n\r\n   init() {\r\n      // объединяем дефолтные настройки с настройками галереи\r\n      this.options = Gallery.extend({}, Gallery.defaults, this.setup);\r\n      // формируем каркас галереи\r\n      this.setSizeCarousel();\r\n      // заполняем массив с координатами X каждого элемента слайдера\r\n      this.setCoordinates();\r\n      // формируем управление слайдером в зависимости от настроек\r\n      this.initControl();\r\n      if (this.options.galleryPopup) {\r\n         this.galleryPopup();\r\n      }\r\n      // устанавливаем обработчики событий, если ещё не устанавливались\r\n      if (this.events) return;\r\n      this.registerEventsHandler();\r\n   }\r\n\r\n   setSizeCarousel() {\r\n      // получаем ширину слайдера - вьюпорт, в котором прокручиваются элементы галереи\r\n      this.widthSlider = this.slider.offsetWidth;\r\n\r\n      // если разрешена адаптация галереи, то необходимо, используя свойство\r\n      // 'options.adaptive', получить значения разрешений (контрольные точки),\r\n      // при которых будут меняться количество видимых элементов галереи и\r\n      // и другие её настройки\r\n      if (this.options.responsive) this.setAdaptiveOptions();\r\n      // максимальный индекс, который может быть у текущего элемента\r\n      // чтобы на последней странице галереи при использовании пагинатора\r\n      // наблюдалось кол-во элементов равное options.visibleItems\r\n      this.max = this.count - this.options.visibleItems;\r\n\r\n      // получаем ширину элемента слайдера, которая зависит от колличества\r\n      // одновременно видимых элементов, размера отступа между элементами и\r\n      // общей ширины слайдера\r\n      // от ширины слайдера вычитаем сумму отступов\r\n      // уменьшенную на 1, т.к. отступ последнего видимого элемента не попадает\r\n      // в окно слайдера (контейнер '.stage')\r\n      const width = (this.widthSlider - this.options.spaceBetween * (this.options.visibleItems - 1)) / this.options.visibleItems;\r\n\r\n      // значение, по которому отсчитываются координаты\r\n      // состоит из ширины элемента слайдера и его margin-right\r\n      // другими словами - растоянием между левыми границами элементов слайдера\r\n      this.width = width + this.options.spaceBetween;\r\n      // ширина контейнера '.stage', непосредственно в котором\r\n      // расположены элементы слайдера\r\n      this.widths = this.width * this.count;\r\n      // задаётся стиль ширины контейнера '.stage'\r\n      this.stage.style.width = this.widths + 'px';\r\n      // перебираем коллекцию элементов слайдера и\r\n      // прописываем ширину и правый отступ для каждого элемента\r\n      for (let item of this.items) {\r\n         item.style.cssText = `width:${width}px; margin-right:${this.options.spaceBetween}px;`;\r\n      }\r\n\r\n      // после того, как каркас галереи построен, все размеры элементов\r\n      // вычислены и прописаны в стилях, делаем карусель видимой через\r\n      // свойство стиля 'visibility'\r\n      if (this.options.visibilityStart) {\r\n         this.gallery.style.visibility = 'hidden'\r\n         setTimeout(() => { this.gallery.style.visibility = 'visible' }, 350);\r\n      }\r\n\r\n   }\r\n\r\n   setCoordinates() {\r\n      // координата первого элемента, от неё и будет идти отсчёт\r\n      let point = 0;\r\n      // добавляем новое свойство в объект 'options'\r\n      // пока это пустой массив\r\n      this.coordinates = [];\r\n\r\n      // заполняем в цикле массив пока количество его элементов\r\n      // не станет равно количеству элементов слайдера,\r\n      // т.е. будет записана координата X каждого элемента\r\n      while (this.coordinates.length < this.count) {\r\n         // добавляем в конец массива текущее значение переменной 'point'\r\n         // которое равно координате X текущего элемента слайдера\r\n         this.coordinates.push(point);\r\n         // вычитаем из текущей координаты ширину блока, равную\r\n         // сумме ширины элемента слайдера и отступа или другими\r\n         // словами - расстояние между левыми границами элементов\r\n         point -= this.width;\r\n      }\r\n   }\r\n\r\n   initControl() {\r\n      // объект с кнопками навигации 'prev / next'\r\n      this.navGallery = this.gallery.querySelector('.nav-gallery');\r\n      // объект перелистывания галереи с помощью пагинации\r\n      this.dottsGallery = this.gallery.querySelector('.dotts-gallery');\r\n\r\n      if (this.options.nav === true) {\r\n         // кнопка 'prev'\r\n         this.btnPrev = this.navGallery.querySelector('[data-shift=prev]');\r\n         // кнопка 'next'\r\n         this.btnNext = this.navGallery.querySelector('[data-shift=next]');\r\n         // устанавливаем стили для кнопок 'prev' и 'next'\r\n         this.setNavStyle();\r\n         // делаем навигацию видимой\r\n         this.navGallery.dataset.hidden = false;\r\n      } else {\r\n         // делаем навигацию невидимой\r\n         this.navGallery.dataset.hidden = true;\r\n      }\r\n\r\n      if (this.options.dotts === true) {\r\n         // формируем постраничную навигацию\r\n         this.creatDotsCtrl();\r\n         // делаем постраничную навигацию видимой\r\n         this.dottsGallery.dataset.hidden = false;\r\n      } else {\r\n         // делаем постраничную навигацию невидимой\r\n         this.dottsGallery.dataset.hidden = true;\r\n      }\r\n   }\r\n\r\n   setAdaptiveOptions() {\r\n      // размер видимой части окна браузера\r\n      const width = document.documentElement.clientWidth;\r\n      // массив с контрольными точками\r\n      const points = [];\r\n      // текущая контрольная точка\r\n      let point;\r\n      // получаем массив из контрольных точек (break point)\r\n      for (let key in this.options.adaptive) {\r\n         points.push(key);\r\n      }\r\n\r\n      // сравнивая ширину страницы (документа) со значениями break point из массива,\r\n      // определяем ближайшую контрольную точку 'снизу'. Эта точка будет служить\r\n      // ключом к объекту с настройками для данного диапазона ширины страницы\r\n      for (let i = 0, j = points.length; i < j; i++) {\r\n         let a = points[i],\r\n            b = (points[i + 1] !== undefined) ? points[i + 1] : points[i];\r\n\r\n         if (width <= points[0]) {\r\n            point = points[0];\r\n         } else if (width >= a && width < b) {\r\n            point = a;\r\n         } else if (width >= points[points.length - 1]) {\r\n            point = points[points.length - 1];\r\n         }\r\n      }\r\n\r\n      // записываем полученные из object[point] настройки в options\r\n      // данные настройки будут записаны поверх существующих\r\n      const setting = this.options.adaptive[point];\r\n      for (let key in setting) {\r\n         this.options[key] = setting[key];\r\n      }\r\n   }\r\n\r\n   setNavStyle() {\r\n      // убираем у всех кнопок класс 'disable', теперь\r\n      // обе кнопки выглядят активными\r\n      this.btnPrev.classList.remove('disable');\r\n      this.btnNext.classList.remove('disable');\r\n\r\n      if (this.current == 0) {\r\n         // если первый элемент является текущим, то блокируем попытку просмотра\r\n         // предыдущего элемента, т.к. его не существует и делаем кнопку\r\n         // 'prev' неактивной\r\n         this.btnPrev.classList.add('disable');\r\n      } else if (this.current >= this.count - this.options.visibleItems) {\r\n         // если последний элемент появился на экране, при этом не важен\r\n         // его индекс, блокируем и делаем неактивной кнопку просмотра след.\r\n         // элемента на экране будет наблюдаться столько элементов,\r\n         // сколько указано в visibleItems\r\n         this.btnNext.classList.add('disable');\r\n      }\r\n   }\r\n\r\n   creatDotsCtrl() {\r\n      // массив с элементы управления постраничной навигацией\r\n      this.spots = [];\r\n      // при ресайзе страницы удаляем элементы постраничной навигации, т.к\r\n      // она будет перестроена исходя из новых настроек, актуальных для текущего\r\n      // разрешения (ширины экрана)\r\n      this.dottsGallery.innerHTML = '';\r\n\r\n      // создаём элемент списка, внутри которых будут находится\r\n      // элементы, управляющие постраничной навигацией\r\n      const li = document.createElement('li');\r\n      // создаём элемент span, который будет отображать точку\r\n      const span = document.createElement('span');\r\n\r\n      let i = 0, point = 0, clone;\r\n\r\n      // добавляем созданный элемент 'span' в элемент списка 'li'\r\n      li.appendChild(span);\r\n      while (i < this.count) {\r\n         // создаём клон полученного элемента списка\r\n         clone = li.cloneNode(true);\r\n         // добавляем клон (элемент 'li') в конец объекта 'dotsCtrl'\r\n         this.dottsGallery.appendChild(clone);\r\n         // и в массив\r\n         this.spots.push(clone);\r\n\r\n         // увеличиваем i на количество видимых элементов галереи\r\n         i += this.options.visibleItems;\r\n         // рассчитываем следующую координату Х, к которой необходимо прокрутить\r\n         // слайдер при постраничной навигации\r\n         point = (i <= this.max) ? point - this.width * this.options.visibleItems : -this.width * this.max;\r\n      }\r\n      this.setDotsStyle();\r\n   }\r\n\r\n   setDotsStyle() {\r\n      // перебираем массив и делаем все элементы массива неактивными\r\n      for (let spot of this.spots) {\r\n         spot.classList.remove('active');\r\n      }\r\n      // находим индекс элемента, который необходимо сделать активным\r\n      // метод Math.trunc() возвращает целую часть числа путём удаления всех дробных знаков.\r\n      const i = (this.next < this.max) ? Math.trunc(this.next / this.options.visibleItems) : this.spots.length - 1;\r\n      // добавляем класс элементу с найденным индексом\r\n      this.spots[i].classList.add('active');\r\n   }\r\n\r\n   ///////////////////////////////////////////////////\r\n\r\n   /* регистрация обработчиков событий */\r\n\r\n   registerEventsHandler(e) {\r\n      // регистрируем обработчик изменения размеров окна браузера\r\n      window.addEventListener('resize', this.resize.bind(this));\r\n      // автоматическое прокручивание, запускается установкой в настройках\r\n      // значения свойства 'autoScroll' в true\r\n      // т.к. мы делаем слайдер, а не карусель использовать автоскролл лучше\r\n      // при выводе только одного изображения\r\n      if (this.options.autoScroll) {\r\n         setInterval(() => this.autoScroll(), this.options.interval);\r\n      }\r\n      // управление кликом по кнопкам 'prev / next' объекта 'navCtrl'\r\n      if (this.options.nav) {\r\n         this.navGallery.addEventListener('click', this.navControl.bind(this));\r\n      }\r\n      // управление постраничной навигацией точками\r\n      if (this.options.dotts) {\r\n         this.dottsGallery.addEventListener('click', this.dotsControl.bind(this));\r\n      }\r\n\r\n\r\n      // управление клавишами вправо / влево\r\n      // будет корректно работать, если на странице только одна галерея, \r\n      // по умолчанию управление отключено\r\n      if (this.options.keyControl) {\r\n         window.addEventListener('keydown', this.keyControl.bind(this));\r\n      }\r\n\r\n      // управление колёсиком мыши, управление работает, если указатель\r\n      // мыши находится над DIV'ом с классом 'slider'\r\n      if (this.options.wheel) {\r\n         this.slider.addEventListener('wheel', this.wheelControl.bind(this));\r\n      }\r\n\r\n      if (this.options.mouse) {\r\n         // mouse events\r\n         // нажатие кнопки мыши на слайдер\r\n         this.stage.addEventListener('mousedown', this.tap.bind(this));\r\n         // прокрутка слайдера перемещением мыши \r\n         this.stage.addEventListener('mousemove', this.drag.bind(this));\r\n         // отпускание кнопки мыши\r\n         this.stage.addEventListener('mouseup', this.release.bind(this));\r\n         // курсор мыши выходит за пределы DIV'а с классом 'slider'\r\n         this.stage.addEventListener('mouseout', this.release.bind(this));\r\n      }\r\n\r\n      if (this.options.touch) {\r\n         // touch events\r\n         // касание экрана пальцем\r\n         this.stage.addEventListener('touchstart', this.tap.bind(this));\r\n         // перемещение пальца по экрану (swipe)\r\n         this.stage.addEventListener('touchmove', this.drag.bind(this));\r\n         // палец отрывается от экрана\r\n         this.stage.addEventListener('touchend', this.release.bind(this));\r\n\r\n         // флаг, информирующий о том, что обработчики событий установлены\r\n         this.events = true;\r\n      }\r\n\r\n   }\r\n\r\n   resize() {\r\n      // обнуляем таймер\r\n      clearTimeout(this.resizeTimer);\r\n      // чтобы уменьшить нагрузку, обработку изменившихся параметров производим\r\n      // через заданный период времени, используя таймер-планировщик\r\n      this.resizeTimer = setTimeout(() => {\r\n         // инициализируем галерею с учётом нового разрешения экрана\r\n         this.init();\r\n         // получаем новый индекс текущего элемента\r\n         this.current = (this.current <= this.max) ? this.current : this.max;\r\n         // после изменения каркаса слайдера под новое разрешение,\r\n         // находим новую координату текущего элемента\r\n         let x = this.coordinates[this.current];\r\n         // прокручиваем слайдер до элемента, который до начала ресайзинга\r\n         // был текущим\r\n         this.scroll(x, this.options.baseTransition);\r\n      }, this.options.delayTimer);\r\n   }\r\n\r\n   // автоматическое прокручивание галереи\r\n   autoScroll(e) {\r\n      // получаем координату Х элемента, до которого должен переместиться слайдер\r\n      // галерея всегда прокручивается вправо, поэтому аргумент, через который\r\n      // передаётся direction, всегда равен 1\r\n      const x = this.getNextCoordinates(1)\r\n      // запускаем прокручивание галереи\r\n      this.scroll(x, this.options.baseTransition);\r\n   }\r\n\r\n   // управление галерей кнопками 'prev / next'\r\n   navControl(e) {\r\n      // если клик был сделан не по элементу 'span' объекта\r\n      // navCtrl, прекращаем работу функции\r\n      if (e.target.tagName != 'SPAN') return;\r\n      // определяем направление прокручивания галереи\r\n      // зависит от кнопки, по которой был сделан клик\r\n      // -1 - prev, 1 - next\r\n      const d = (e.target.dataset.shift === 'next') ? 1 : -1;\r\n      // получаем координату Х элемента, до которого должен переместиться слайдер\r\n      const x = this.getNextCoordinates(d)\r\n      // запускаем прокручивание галереи\r\n      this.scroll(x, this.options.baseTransition);\r\n   }\r\n\r\n   // пролистываем галерею на колличество видимых элементов\r\n   // с помощью постраничной навигации\r\n   dotsControl(e) {\r\n      // если клик был сделан не по элементу 'span' объекта dotsCtrl или\r\n      // по активному элементу, соответствующему текущей странице,\r\n      // прекращаем работу функции\r\n      if (e.target.tagName != 'LI' || e.target.classList.contains('active')) return;\r\n\r\n      // находим индекс элемента 'span' в массиве 'spots'\r\n      // этот индекс понадобится для поиска координаты\r\n      // в массиве 'coordinates'\r\n      const i = this.spots.indexOf(e.target);\r\n      // если элемент в массиве 'spots' не найден, прекращаем работу функции\r\n      if (i == -1) return;\r\n\r\n      // получаем индекс координаты, до которой будет прокручиваться галерея\r\n      this.next = i * this.options.visibleItems;\r\n      // ограничиваем индекс координаты, чтобы при переходе на последнюю страницу,\r\n      // она была полностью заполнена, т.е. на последней странице должно быть\r\n      // всегда visibleItems элементов\r\n      this.next = (this.next <= this.max) ? this.next : this.max;\r\n      // координата, до которой будет происходить scroll\r\n      const x = this.coordinates[this.next];\r\n      // вычисляем, на сколько элементов будет прокручена галерея\r\n      const n = Math.abs(this.current - this.next);\r\n      // увеличиваем время анимации скролла в зависимости от количества\r\n      // прокручиваемых элементов\r\n      const t = this.options.baseTransition + n * 0.07;\r\n\r\n      // запускаем прокручивание галереи\r\n      this.scroll(x, t);\r\n   }\r\n   // листаем галерею с помощью клавиатуры\r\n   keyControl(e) {\r\n      // проверяем код нажатой клавиши и исходя из полученного\r\n      // кода определяем направление прокручивания галереи\r\n      // если код не соотвествует клавишам 'влево' или 'вправо',\r\n      // прекращаем работу функции\r\n      if (e.which !== Gallery.RIGHT && e.which !== Gallery.LEFT) return;\r\n      const d = (e.which === Gallery.RIGHT) ? 1 : -1;\r\n      // получаем координату Х элемента, до которого должна переместиться галерея\r\n      const x = this.getNextCoordinates(d)\r\n      // запускаем прокручивание галереи\r\n      this.scroll(x, this.options.baseTransition);\r\n   }\r\n\r\n   // листаем галерею вращая колёсико мыши\r\n   wheelControl(e) {\r\n      // отключаем поведение по умолчанию - скролл страницы\r\n      e.preventDefault();\r\n      // определяем направление перемещения в зависимости от направления\r\n      // вращения колёсика мыши\r\n      const d = (e.deltaY > 0) ? 1 : -1;\r\n      // получаем координату Х элемента, до которого должен переместиться слайдер\r\n      const x = this.getNextCoordinates(d)\r\n      // запускаем прокручивание галереи\r\n      this.scroll(x, this.options.baseTransition);\r\n   }\r\n\r\n   // обработчик нажатия левой кнопки мыши на слайдер или\r\n   // касание (тап) пальцем\r\n   tap(e) {\r\n      // отключаем действия по умолчанию\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n      // если нажата не левая кнопка мыши, прекращаем работу функции\r\n      if (e.which && e.which != 1) return;\r\n      // расстояние от левой границы экрана до курсора без учета прокрутки,\r\n      // т. е. начальная координата Х, с которой начато перетаскивание\r\n      this.start = Gallery.xpos(e);\r\n      // устанавливаем флаг нажатия\r\n      this.pressed = true;\r\n   }\r\n\r\n   // прокрутка слайдера перемещением мыши или перемещение пальца по экрану (swipe) \r\n   drag(e) {\r\n      // отключаем действия по умолчанию\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n\r\n      // если не нажата левая кнопка мыши, прекращаем работу функции\r\n      if (this.pressed === false) return;\r\n\r\n      // смещение курсора мыши или пальца от начальной позиции\r\n      this.shift = this.start - Gallery.xpos(e);\r\n      // исключаем дрожание курсора или пальца\r\n      if (Math.abs(this.shift) < 3) return;\r\n\r\n      // общая ширина всех невидимых в данный момент элементов слайдера\r\n      const remaining = this.widths - this.width * this.options.visibleItems;\r\n      // разница между текущей координатой и смещением курсора от\r\n      // точки старта, с которой начато перетаскивание\r\n      const delta = this.coordinates[this.current] - this.shift;\r\n      // останавливаем прокручивание галереи при достижении первого или последнего элемента\r\n      if (delta > this.options.limit || Math.abs(delta) - remaining > this.options.limit) return;\r\n\r\n      // перемещаем слайдер на величину смещения курсора относительно\r\n      // точки старта (начальной координаты Х)\r\n      this.scroll(delta, 0);\r\n   }\r\n\r\n   // отпускание кнопки мыши или палец отрывается от экрана\r\n   // курсор мыши выходит за пределы DIV'а с классом 'slider'\r\n   release(e) {\r\n      // отключаем действия по умолчанию\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n\r\n      // если не было нажатия на кнопку мыши или тапа пальцем,\r\n      // прекращаем работу функции\r\n      if (this.pressed === false) return;\r\n\r\n      // рассчитываем направление прокрутки галереи\r\n      const d = (Math.abs(this.shift) > this.width / 2) ? Math.round(this.shift / this.width) : '';\r\n      // определяем координату X ближайшего элемента\r\n      const x = this.getNextCoordinates(d)\r\n\r\n      // запускаем доводку прокручивания галереи к ближайшему элементу\r\n      this.scroll(x, this.options.baseTransition);\r\n      // сбрасываем флаг\r\n      this.pressed = false;\r\n   }\r\n\r\n   galleryPopup() {\r\n      const popups = document.querySelectorAll('#gallery-popup')\r\n      for (let index = 0; index < popups.length; index++) {\r\n         this.popup = popups[index];\r\n         this.imageItems = document.querySelectorAll('[data-clickImg]')\r\n         this.btnClose = this.popup.querySelector('.popup__close')\r\n         if (!this.popup.classList.contains('_show')) {\r\n            for (let index = 0; index < this.imageItems.length; index++) {\r\n               this.imageItem = this.imageItems[index];\r\n               this.imageItem.addEventListener('click', this.galleryPopupOpen.bind(this))\r\n            }\r\n         }\r\n\r\n         this.popup.addEventListener('click', this.galleryPopupClose.bind(this))\r\n         this.btnClose.addEventListener('click', this.galleryPopupCloseBtn.bind(this))\r\n      }\r\n\r\n   }\r\n   galleryPopupOpen(e) {\r\n      e.preventDefault()\r\n      this.popup.classList.add('_show')\r\n      const PaddingLock = window.innerWidth - document.querySelector('.wrapper').offsetWidth + 'px'\r\n      document.body.classList.add('_lock')\r\n      document.querySelector('.wrapper').style.paddingRight = PaddingLock\r\n      document.querySelector('.header__wrapper').style.paddingRight = PaddingLock\r\n      const targetItem = e.currentTarget\r\n      let indexItem = Array.from(this.imageItems).indexOf(targetItem)\r\n      this.current = indexItem\r\n      this.next = this.current + 1;\r\n      if (indexItem == -1) return;\r\n      this.next = indexItem * this.options.visibleItems;\r\n      this.next = (this.next <= this.max) ? this.next : this.max;\r\n      const x = this.coordinates[this.next];\r\n      const n = Math.abs(this.current - this.next);\r\n      const t = this.options.baseTransition + n * 0.07;\r\n\r\n      this.scroll(x, t);\r\n\r\n   }\r\n   galleryPopupClose(e) {\r\n      if (this.popup.classList.contains('_show')) {\r\n         if (!e.target.closest('.item picture') && !e.target.closest('.popup__close') && !e.target.closest('.control-gallery')) {\r\n            this.popup.classList.remove('_show')\r\n            document.body.classList.remove('_lock')\r\n            document.querySelector('.wrapper').style.paddingRight = '0px'\r\n            document.querySelector('.header__wrapper').style.paddingRight = '0px'\r\n         }\r\n\r\n      }\r\n   }\r\n   galleryPopupCloseBtn(e) {\r\n      e.preventDefault()\r\n      if (this.popup.classList.contains('_show')) {\r\n         this.popup.classList.remove('_show')\r\n         document.body.classList.remove('_lock')\r\n         document.querySelector('.wrapper').style.paddingRight = '0px'\r\n         document.querySelector('.header__wrapper').style.paddingRight = '0px'\r\n      }\r\n\r\n   }\r\n   ///////////////////////////////////////////////////\r\n\r\n   /* Прокручивание галереи */\r\n\r\n   getNextCoordinates(direction) {\r\n      if (typeof (direction) !== 'number') return this.coordinates[this.current];\r\n      // direction - направление перемещения: -1 - left, 1 - right\r\n      if (this.options.autoScroll && this.current >= this.count - this.options.visibleItems) {\r\n         this.next = 0;\r\n      } else {\r\n         // попытка прокрутить к предыдущему элементу, когда текущим является первый элемент\r\n         if (this.current == 0 && direction == -1 ||\r\n            // попытка просмотреть следующую группу элементов при постраничной навигации, но\r\n            // все элементы после текущего выведены во вьюпорт слайдера\r\n            (this.current >= this.max) && direction == 1) return;\r\n         // получаем индекс следующего элемента\r\n         this.next += direction;\r\n      }\r\n      // возвращаем координату след. элемента - координату, до которой\r\n      // необходимо продвинуть галерею\r\n      return this.coordinates[this.next];\r\n   }\r\n\r\n   scroll(x, transition) {\r\n      // если аргумент х не является числом, прекращаем работу функции\r\n      if (typeof (x) !== 'number') return;\r\n\r\n      // прописываем новые стили для смещения (прокручивания) галереи\r\n      // к следующему элементу\r\n      this.stage.style.cssText = `width:${this.widths}px; height:${this.items[0].offsetHeight}px; transform:translateX(${x}px); transition:${transition}s`;\r\n      // после прокручивания, индекс след. элемента становится текущим\r\n      this.current = (this.next < this.max) ? this.next : this.max;\r\n\r\n      // меняем стили отображения кнопок управления в зависимости от\r\n      // текущего индекса\r\n      if (this.options.nav) this.setNavStyle();\r\n      // меняем стили элементов постраничной навигации\r\n      if (this.options.dotts) this.setDotsStyle();\r\n   }\r\n}\r\n"]}